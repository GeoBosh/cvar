[{"path":"https://geobosh.github.io/cvar/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Georgi N. Boshnakov. Author, maintainer.","code":""},{"path":"https://geobosh.github.io/cvar/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Boshnakov GN (2022). cvar: Compute Expected Shortfall Value Risk Continuous Distributions. https://geobosh.github.io/cvar/ (doc), https://github.com/GeoBosh/cvar (devel).","code":"@Manual{,   title = {cvar: Compute Expected Shortfall and Value at Risk for Continuous Distributions},   author = {Georgi N. Boshnakov},   year = {2022},   note = {https://geobosh.github.io/cvar/ (doc), https://github.com/GeoBosh/cvar (devel)}, }"},{"path":[]},{"path":"https://geobosh.github.io/cvar/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Compute Expected Shortfall and Value at Risk for Continuous Distributions","text":"Compute expected shortfall (ES) Value Risk (VaR) quantile function, distribution function, random number generator probability density function. ES also known Conditional Value Risk (CVaR). Virtually continuous distribution can specified. functions vectorised arguments. computations done directly definitions, see e.g. Acerbi Tasche (2002). support GARCH models provided, well.","code":""},{"path":"https://geobosh.github.io/cvar/index.html","id":"installing-cvar","dir":"","previous_headings":"","what":"Installing cvar","title":"Compute Expected Shortfall and Value at Risk for Continuous Distributions","text":"latest stable version CRAN. vignette Guide_cvar shipping package gives illustrative examples (can also opened R vignette(\"Guide_cvar\", package = \"cvar\")). can install development version cvar Github:","code":"install.packages(\"cvar\") library(devtools) install_github(\"GeoBosh/cvar\")"},{"path":"https://geobosh.github.io/cvar/index.html","id":"overview-1","dir":"","previous_headings":"","what":"Overview","title":"Compute Expected Shortfall and Value at Risk for Continuous Distributions","text":"Package cvar small R package , essentially two functions — ES computing expected shortfall VaR Value Risk. user specifies distribution supplying one functions define continuous distribution—currently can quantile function (qf), cumulative distribution function (cdf) probability density function (pdf). Virtually continuous distribution can specified. functions vectorised parameters distributions, making bulk computations convenient, example forecasting model evaluation. name package, “cvar”, comes Conditional Value Risk (CVaR), alternative term expected shortfall. chose use standard names ES VaR, despite possibility name clashes named functions packages, rather invent possibly difficult remember alternatives. Just call functions cvar::ES cvar::VaR necessary. Locations-scale transformations can specified separately distribution parameters. useful parameters provided directly distribution hand. use parameters often leads efficient computations better numerical accuracy even distribution parameters purpose. examples VaR ES illustrate Gaussian distribution. Since VaR quantile, functions computing given distribution convenience functions. VaR exported cvar attractive certain workflows vectorised distribution parameters, location-scale transformation possibility compute cdf’s quantile functions available.","code":""},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute expected shortfall (ES) of distributions — ES","title":"Compute expected shortfall (ES) of distributions — ES","text":"Compute expected shortfall distribution.","code":""},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute expected shortfall (ES) of distributions — ES","text":"","code":"ES(dist, p_loss = 0.05, ...)  # S3 method for default ES(   dist,   p_loss = 0.05,   dist.type = \"qf\",   qf,   ...,   intercept = 0,   slope = 1,   control = list(),   x )  # S3 method for numeric ES(   dist,   p_loss = 0.05,   dist.type = \"qf\",   qf,   ...,   intercept = 0,   slope = 1,   control = list(),   x )"},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute expected shortfall (ES) of distributions — ES","text":"dist specifies distribution whose ES computed, usually function name function computing quantiles, cdf, pdf, random number generator, see Details. p_loss level, default 0.05. ... passed dist. dist.type character string specifying computed dist, \"qf\" \"cdf\". qf quantile function, used dist.type = \"pdf\". intercept, slope compute ES linear transformation intercept + slope*X, X distribution specified dist, see Details. control additional control parameters numerical integration routine. x deprecated soon removed. x renamed p_loss, please use latter.","code":""},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute expected shortfall (ES) of distributions — ES","text":"numeric vector","code":""},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute expected shortfall (ES) of distributions — ES","text":"ES computes expected shortfall distributions specified     arguments. dist typically function (name one). dist     computes determined dist.type, whose default setting \"qf\" (    quantile function). possible settings dist.type include \"cdf\"     \"pdf\".  Additional arguments dist can given     \"...\" arguments. Argument dist can also numeric vector. case ES computed,     effectively, empirical cumulative distribution function (ecdf)     vector. ecdf created explicitly quantile     function used instead computation VaR. Arguments \"...\"     passed eventually quantile() can used, example, select     non-defult method computation quantiles. Except exceptions discussed , function computing VaR specified     distribution constructed expected shortfall computed numerically     integrating . numerical integration can fine-tuned argument     control, named list, see integrate     available options. dist.type \"pdf\", VaR computed, Instead, partial     expectation lower tail computed numerical integration x *     pdf(x).  Currently quantile function required anyway, via argument qf,     compute upper limit integral. , case mainly testing     comparison purposes. bunch expected shortfalls computed argument x     arguments \"...\" length greater one. recycled equal     length, necessary, using normal R recycling rules. intercept slope can used compute expected shortfall     location-scale transformation Y = intercept + slope * X,     distribution X specified parameters Y     variable interest. expected shortfall X calculated     transformed Y. Note distribution X need     standardised, although typically . intercept slope can vectors. Using may     particularly useful cheap calculations , example, forecasting,     predictive distributions often family, different location     scale parameters. Conceptually, described treatment intercept     slope equivalent recycling along arguments,     efficiently. names, intercept slope, location scale parameters     chosen expressiveness minimise possibility clash     parameters dist (e.g., Gamma distribution parameter scale).","code":""},{"path":[]},{"path":"https://geobosh.github.io/cvar/reference/ES.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute expected shortfall (ES) of distributions — ES","text":"","code":"ES(qnorm) #> [1] 2.062713  ## Gaussian ES(qnorm, dist.type = \"qf\") #> [1] 2.062713 ES(pnorm, dist.type = \"cdf\") #> [1] 2.062713  ## t-dist ES(qt, dist.type = \"qf\", df = 4) #> [1] 3.20287 ES(pt, dist.type = \"cdf\", df = 4) #> [1] 3.20287  ES(pnorm, 0.95, dist.type = \"cdf\") #> [1] 0.1085638 ES(qnorm, 0.95, dist.type = \"qf\") #> [1] 0.1085638 ## - VaRES::esnormal(0.95, 0, 1) ## - PerformanceAnalytics::ETL(p=0.05, method = \"gaussian\", mu = 0, ##                             sigma = 1, weights = 1)             # same  cvar::ES(pnorm, dist.type = \"cdf\") #> [1] 2.062713 cvar::ES(qnorm, dist.type = \"qf\") #> [1] 2.062713 cvar::ES(pnorm, 0.05, dist.type = \"cdf\") #> [1] 2.062713 cvar::ES(qnorm, 0.05, dist.type = \"qf\") #> [1] 2.062713  ## this uses \"pdf\" cvar::ES(dnorm, 0.05, dist.type = \"pdf\", qf = qnorm) #> [1] 2.062713   ## this gives warning (it does more than simply computing ES): ## PerformanceAnalytics::ETL(p=0.95, method = \"gaussian\", mu = 0, sigma = 1, weights = 1)  ## run this if VaRRES is present if (FALSE) { x <- seq(0.01, 0.99, length = 100) y <- sapply(x, function(p) cvar::ES(qnorm, p, dist.type = \"qf\")) yS <- sapply(x, function(p) - VaRES::esnormal(p)) plot(x, y) lines(x, yS, col = \"blue\") }"},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":null,"dir":"Reference","previous_headings":"","what":"Specify a GARCH model — GarchModel","title":"Specify a GARCH model — GarchModel","text":"Specify GARCH model.","code":""},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Specify a GARCH model — GarchModel","text":"","code":"GarchModel(model = list(), ..., model.class = NULL)"},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Specify a GARCH model — GarchModel","text":"model GARCH model list. ... named arguments specifying GARCH model. model.class class result. default GarchModel() decides class result.","code":""},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Specify a GARCH model — GarchModel","text":"object suitable GARCH-type class","code":""},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Specify a GARCH model — GarchModel","text":"Argument model can result previous call GarchModel. Arguments \"...\" overwrite current components model. GarchModel guarantees code using continue work transparently user even internal represedtation GARCH models package changed additional functionality added.","code":""},{"path":"https://geobosh.github.io/cvar/reference/GarchModel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Specify a GARCH model — GarchModel","text":"","code":"## GARCH(1,1) with Gaussian innovations mo1a <- GarchModel(omega = 1, alpha = 0.3, beta = 0.5) mo1b <- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, cond.dist = \"norm\")  ## equivalently, the parameters can be given as a list p1 <- list(omega = 1, alpha = 0.3, beta = 0.5) mo1a_alt <- GarchModel(p1) mo1b_alt <- GarchModel(p1, cond.dist = \"norm\") stopifnot(identical(mo1a, mo1a_alt), identical(mo1b, mo1b_alt))  ## additional arguments modify values already in 'model' mo_alt <- GarchModel(p1, beta = 0.4)  ## set also initial values mo2 <- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, esp0 = - 1.5, h0 = 4.96)  ##  GARCH(1,1) with standardised-t_5 mot <- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, cond.dist = list(\"std\", nu = 5))"},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Value-at-Risk (VaR) — VaR","title":"Compute Value-at-Risk (VaR) — VaR","text":"VaR computes Value--Risk distribution specified     arguments. meaning parameters ES, including     recycling rules.","code":""},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Value-at-Risk (VaR) — VaR","text":"","code":"VaR(dist, p_loss = 0.05, ...)  VaR_qf(   dist,   p_loss = 0.05,   ...,   intercept = 0,   slope = 1,   tol = .Machine$double.eps^0.5,   x )  VaR_cdf(   dist,   p_loss = 0.05,   ...,   intercept = 0,   slope = 1,   tol = .Machine$double.eps^0.5,   x )  # S3 method for default VaR(   dist,   p_loss = 0.05,   dist.type = \"qf\",   ...,   intercept = 0,   slope = 1,   tol = .Machine$double.eps^0.5,   x )  # S3 method for numeric VaR(dist, p_loss = 0.05, ..., intercept = 0, slope = 1, x)"},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Value-at-Risk (VaR) — VaR","text":"dist specifies distribution whose ES computed, usually function name function computing quantiles, cdf, pdf, random number generator, see Details. p_loss level, default 0.05. ... passed dist. intercept, slope compute VaR linear transformation intercept + slope*X, X distribution specified dist, see Details. tol tollerance x deprecated soon removed. x renamed p_loss, please use latter. dist.type character string specifying computed dist, \"qf\" \"cdf\".","code":""},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Value-at-Risk (VaR) — VaR","text":"VaR S3 generic. meaning parameters default method     ES, including recycling rules. VaR_qf VaR_cdf streamlined, non-generic, variants common     case \"...\" parameters scalar. parameters x,     intercept, slope can vectors, VaR. Argument dist can also numeric vector. case ES computed,     effectively, empirical cumulative distribution function (ecdf)     vector. ecdf created explicitly quantile     function used instead computation VaR. Arguments \"...\"     passed eventually quantile() can used, example, select     non-defult method computation quantiles. practice, may need compute VaR associated data. distribution comes     fitting model. simplest case, fit distribution data,     assuming sample ..d. example, normal distribution \\(N(\\mu,     \\sigma^2)\\) can fitted using sample mean sample variance estimates     unknown parameters \\(\\mu\\) \\(\\sigma^2\\), see section ‘Examples’.     common distributions specialised functions fit parameters     , general optimisation routines can used. soffisticated models may     used, even time series models GARCH mixture autoregressive models.","code":""},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute Value-at-Risk (VaR) — VaR","text":"use traditional definition VaR negated lower quantile. example,     \\(X\\) returns asset, VAR\\({}_\\alpha\\) = \\(-q_\\alpha\\),     \\(q_\\alpha\\) lower \\(\\alpha\\) quantile \\(X\\).     Equivalently, VAR\\({}_\\alpha\\) equal lower \\(1-\\alpha\\)     quantile \\(-X\\).","code":""},{"path":[]},{"path":"https://geobosh.github.io/cvar/reference/VaR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Value-at-Risk (VaR) — VaR","text":"","code":"cvar::VaR(qnorm, c(0.01, 0.05), dist.type = \"qf\") #> [1] 2.326348 1.644854  ## the following examples use these values, obtained by fitting a normal distribution to ## some data: muA <- 0.006408553 sigma2A <- 0.0004018977  ## with quantile function, giving the parameters directly in the call: res1 <- cvar::VaR(qnorm, 0.05, mean = muA, sd = sqrt(sigma2A)) res2 <- cvar::VaR(qnorm, 0.05, intercept = muA, slope = sqrt(sigma2A)) abs((res2 - res1)) # 0, intercept/slope equivalent to mean/sd #> [1] 0  ## with quantile function, which already knows the parameters: my_qnorm <- function(p) qnorm(p, mean = muA, sd = sqrt(sigma2A)) res1_alt <- cvar::VaR(my_qnorm, 0.05) abs((res1_alt - res1)) #> [1] 0  ## with cdf the precision depends on solving an equation res1a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", mean = muA, sd = sqrt(sigma2A)) res2a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", intercept = muA, slope = sqrt(sigma2A)) abs((res1a - res2)) # 3.287939e-09 #> [1] 3.287939e-09 abs((res2a - res2)) # 5.331195e-11, intercept/slope better numerically #> [1] 5.331195e-11  ## as above, but increase the precision, this is probably excessive res1b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                    mean = muA, sd = sqrt(sigma2A), tol = .Machine$double.eps^0.75) res2b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                    intercept = muA, slope = sqrt(sigma2A), tol = .Machine$double.eps^0.75) abs((res1b - res2)) # 6.938894e-18 # both within machine precision #> [1] 6.938894e-18 abs((res2b - res2)) # 1.040834e-16 #> [1] 1.040834e-16  ## relative precision is also good abs((res1b - res2)/res2) # 2.6119e-16 # both within machine precision #> [1] 2.6119e-16 abs((res2b - res2)/res2) # 3.91785e-15 #> [1] 3.91785e-15   ## an extended example with vector args, if \"PerformanceAnalytics\" is present if (requireNamespace(\"PerformanceAnalytics\", quietly = TRUE)) withAutoprint({     data(edhec, package = \"PerformanceAnalytics\")     mu <- apply(edhec, 2, mean)     sigma2 <- apply(edhec, 2, var)     musigma2 <- cbind(mu, sigma2)      ## compute in 2 ways with cvar::VaR     vAz1 <- cvar::VaR(qnorm, 0.05, mean = mu, sd = sqrt(sigma2))     vAz2 <- cvar::VaR(qnorm, 0.05, intercept = mu, slope = sqrt(sigma2))      vAz1a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                        mean = mu, sd = sqrt(sigma2))     vAz2a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                        intercept = mu, slope = sqrt(sigma2))      vAz1b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                    mean = mu, sd = sqrt(sigma2),                    tol = .Machine$double.eps^0.75)     vAz2b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\",                    intercept = mu, slope = sqrt(sigma2),                    tol = .Machine$double.eps^0.75)      ## analogous calc. with PerformanceAnalytics::VaR     vPA <- apply(musigma2, 1, function(x)         PerformanceAnalytics::VaR(p = .95, method = \"gaussian\", invert = FALSE,                                   mu = x[1], sigma = x[2], weights = 1))     ## the results are numerically the same     max(abs((vPA - vAz1))) # 5.551115e-17     max(abs((vPA - vAz2))) #   \"\"      max(abs((vPA - vAz1a))) # 3.287941e-09     max(abs((vPA - vAz2a))) #  1.465251e-10, intercept/slope better      max(abs((vPA - vAz1b))) # 4.374869e-13     max(abs((vPA - vAz2b))) # 3.330669e-16 }) #> > data(edhec, package = \"PerformanceAnalytics\") #> > mu <- apply(edhec, 2, mean) #> > sigma2 <- apply(edhec, 2, var) #> > musigma2 <- cbind(mu, sigma2) #> > vAz1 <- cvar::VaR(qnorm, 0.05, mean = mu, sd = sqrt(sigma2)) #> > vAz2 <- cvar::VaR(qnorm, 0.05, intercept = mu, slope = sqrt(sigma2)) #> > vAz1a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", mean = mu, sd = sqrt(sigma2)) #> > vAz2a <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", intercept = mu, slope = sqrt(sigma2)) #> > vAz1b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", mean = mu, sd = sqrt(sigma2),  #> +     tol = .Machine$double.eps^0.75) #> > vAz2b <- cvar::VaR(pnorm, 0.05, dist.type = \"cdf\", intercept = mu, slope = sqrt(sigma2),  #> +     tol = .Machine$double.eps^0.75) #> > vPA <- apply(musigma2, 1, function(x) PerformanceAnalytics::VaR(p = 0.95,  #> +     method = \"gaussian\", invert = FALSE, mu = x[1], sigma = x[2], weights = 1)) #> > max(abs((vPA - vAz1))) #> [1] 4.163336e-17 #> > max(abs((vPA - vAz2))) #> [1] 4.163336e-17 #> > max(abs((vPA - vAz1a))) #> [1] 1.953409e-09 #> > max(abs((vPA - vAz2a))) #> [1] 1.242979e-10 #> > max(abs((vPA - vAz1b))) #> [1] 4.831205e-14 #> > max(abs((vPA - vAz2b))) #> [1] 2.914335e-16"},{"path":"https://geobosh.github.io/cvar/reference/cvar-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","title":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","text":"Compute expected shortfall (ES) Value Risk (VaR)     quantile function, distribution function, random number     generator probability density function.  ES also known     Conditional Value Risk (CVaR). Virtually continuous     distribution can specified.  functions vectorised     arguments. support GARCH models provided, well.","code":""},{"path":"https://geobosh.github.io/cvar/reference/cvar-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","text":"huge number functions computations     distributions core R contributed packages. Pdf's,     cdf's, quantile functions random number generators     covered comprehensively. coverage expected shortfall     patchy large collection distributions, including     functions expected shortfall, provided     Nadarajah et al. (2013) .     Peterson Carl (2018)      Dutang et al. (2008)  provide packages     covering comprehensively various aspects risk measurement,     including functions expected shortfall. Package cvar small package , essentially, two main     functions --- ES computing expected shortfall     VaR Value Risk.  user specifies     distribution supplying one functions define     continuous distribution---currently can quantile     function (qf), cumulative distribution function (cdf)     probability density function (pdf). Virtually continuous     distribution can specified. functions vectorised parameters     distributions, making bulk computations convenient,     example forecasting model evaluation. name package, \"cvar\", comes Conditional     Value Risk (CVaR), alternative term     expected shortfall. chose use standard names ES VaR,     despite possibility name clashes named     functions packages, rather invent possibly     difficult remember alternatives. Just call functions     cvar::ES cvar::VaR necessary. Locations-scale transformations can specified separately     distribution parameters. useful     parameters provided directly distribution     hand. use parameters often leads     efficient computations better numerical accuracy even     distribution parameters purpose.     examples VaR ES illustrate     Gaussian distribution. Since VaR quantile, functions computing given     distribution convenience functions. VaR exported     cvar attractive certain workflows     vectorised distribution parameters, location-scale     transformation, possibility compute cdf's     quantile functions available. support GARCH models provided, well.     currently development, see predict.garch1c1     current functionality. practice, may need compute VaR associated data. distribution comes     fitting model. simplest case, fit distribution data,     assuming sample ..d. example, normal distribution \\(N(\\mu,     \\sigma^2)\\) can fitted using sample mean sample variance estimates     unknown parameters \\(\\mu\\) \\(\\sigma^2\\), see section ‘Examples’.     common distributions specialised functions fit parameters     , general optimisation routines can used. soffisticated models may used,     even time series models GARCH mixture autoregressive models.","code":""},{"path":"https://geobosh.github.io/cvar/reference/cvar-package.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","text":"Christophe Dutang, Vincent Goulet, Mathieu Pigeon (2008). “actuar: R Package Actuarial Science.” Journal Statistical Software, 25(7), 38. doi:10.18637/jss.v025.i07 . Saralees Nadarajah, Stephen Chan, Emmanuel Afuecheta (2013). VaRES: Computes value risk expected shortfall 100 parametric distributions. R package version 1.0, https://CRAN.R-project.org/package=VaRES. Brian G. Peterson, Peter Carl (2018). PerformanceAnalytics: Econometric Tools Performance Risk Analysis. R package version 1.5.2, https://CRAN.R-project.org/package=PerformanceAnalytics.","code":""},{"path":[]},{"path":"https://geobosh.github.io/cvar/reference/cvar-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","text":"Georgi N. Boshnakov","code":""},{"path":"https://geobosh.github.io/cvar/reference/cvar-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Conditional Value-at-Risk and Value-at-Risk — cvar-package","text":"","code":"## see the examples for ES(), VaR(), predict.garch1c1()"},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction for GARCH(1,1) time series — predict.garch1c1","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"Predict GARCH(1,1) time series.","code":""},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"","code":"# S3 method for garch1c1 predict(object, n.ahead = 1, Nsim = 1000, eps, sigmasq, seed = NULL, ...)"},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"object object class \"garch1c1\". n.ahead maximum horizon (lead time) prediction. Nsim number Monte Carlo simulations simulation based quantities. eps time series predict, last value used. sigmasq (squared) volatilities, last value used. seed integer, seed random number generator. ... currently used.","code":""},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"object S3 class \"predict_garch1c1\" containing     following components: eps point predictions (conditional expectations) time series (equal     zero pure GARCH). h point predictions (conditional expectations)squared volatilities. model model. call call. pi_plugin Prediction intervals time series, based plug-    distributions, see Details. pi_sim Simulation based prediction intervals time series, see Details. dist_sim simulation samples predictive distributions time     series volatilties.","code":""},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"Plug-prediction intervals predictive distributions obtained inserting predicted volatility conditional densities. predictions one lag ahead real predictive distributions prediction intervals usually adequate. simulation prediction intervals generate (large) number continuations given time series. Prediction intervals can based sample quantiles. generated samples stored returned object can used exploration predictive distributions. dist_sim$eps contains simulated future values time series dist_sim$h corresponding (squared) volatilities.  matrices whose -th rows contain predicted quantities horizon . random seed start simulations saved returned object.  speficific seed can requested argument seed. case simulations done specified seed old state random number generator restored function returns. setup similar sim_garch1c1.","code":""},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"function development may changed.","code":""},{"path":"https://geobosh.github.io/cvar/reference/predict.garch1c1.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction for GARCH(1,1) time series — predict.garch1c1","text":"","code":"op <- options(digits = 4)  ## set up a model and simulate a time series mo <- GarchModel(omega = 0.4, alpha = 0.3, beta = 0.5) a1 <- sim_garch1c1(mo, n = 1000, n.start = 100, seed = 20220305)  ## predictions for T+1,...,T+5 (T = time of last value) ## Nsim is small to reduce the load on CRAN, usually Nsim is larger. a.pred <- predict(mo, n.ahead = 5, Nsim = 1000, eps = a1$eps,   sigmasq = a1$h, seed = 1234)  ## preditions for the time series a.pred$eps #> [1] 0 0 0 0 0  ## PI's for eps - plug-in and simulated a.pred$pi_plugin #>         lwr   upr #> [1,] -2.484 2.484 #> [2,] -2.544 2.544 #> [3,] -2.591 2.591 #> [4,] -2.628 2.628 #> [5,] -2.658 2.658 a.pred$pi_sim #>        2.5% 97.5% #> [1,] -2.447 2.465 #> [2,] -2.662 2.559 #> [3,] -2.426 2.624 #> [4,] -2.538 2.370 #> [5,] -2.645 2.637  ## a DIY calculation of PI's using the simulated sample paths t(apply(a.pred$dist_sim$eps, 1, function(x) quantile(x, c(0.025, 0.975)))) #>        2.5% 97.5% #> [1,] -2.447 2.465 #> [2,] -2.662 2.559 #> [3,] -2.426 2.624 #> [4,] -2.538 2.370 #> [5,] -2.645 2.637  ## further investigate the predictive distributions t(apply(a.pred$dist_sim$eps, 1, function(x) summary(x))) #>        Min. 1st Qu.    Median      Mean 3rd Qu.  Max. #> [1,] -3.922 -0.8366 -0.064571 -0.004804  0.8683 4.050 #> [2,] -6.755 -0.8333  0.055137  0.012828  0.8895 4.320 #> [3,] -5.198 -0.8541 -0.015145 -0.004674  0.8138 4.290 #> [4,] -3.786 -0.8596 -0.001705 -0.029519  0.7609 4.241 #> [5,] -5.000 -0.8314 -0.019039 -0.016285  0.7956 4.860  ## compare predictive densities for horizons 2 and 5: h2 <- a.pred$dist_sim$eps[2, ] h5 <- a.pred$dist_sim$eps[5, ] main <- \"Predictive densities: horizons 2 (blue) and 5 (black)\" plot(density(h5), main = main) lines(density(h2), col = \"blue\")   ## predictions of sigma_t^2 a.pred$h #> [1] 1.606 1.685 1.748 1.798 1.839  ## plug-in predictions of sigma_t sqrt(a.pred$h) #> [1] 1.267 1.298 1.322 1.341 1.356  ## simulation predictive densities (PD's) of sigma_t for horizons 2 and 5: h2 <- sqrt(a.pred$dist_sim$h[2, ]) h5 <- sqrt(a.pred$dist_sim$h[5, ]) main <- \"PD's of sigma_t for horizons 2 (blue) and 5 (black)\" plot(density(h2), col = \"blue\", main = main) lines(density(h5))   ## VaR and ES for different horizons cbind(h = 1:5,       VaR = apply(a.pred$dist_sim$eps, 1, function(x) VaR(x, c(0.05))),       ES = apply(a.pred$dist_sim$eps, 1, function(x) ES(x, c(0.05))) ) #>      h   VaR    ES #> [1,] 1 2.077 2.593 #> [2,] 2 2.075 2.972 #> [3,] 3 2.106 2.651 #> [4,] 4 2.066 2.680 #> [5,] 5 2.167 2.886  ## fit a GARCH(1,1) model to exchange rate data and predict gmo1 <- fGarch::garchFit(formula = ~garch(1, 1), data = fGarch::dem2gbp,   include.mean = FALSE, cond.dist = \"norm\", trace = FALSE) mocoef <- gmo1@fit$par mofitted <- GarchModel(omega = mocoef[\"omega\"], alpha = mocoef[\"alpha1\"],   beta = mocoef[\"beta1\"]) gmo1.pred <- predict(mofitted, n.ahead = 5, Nsim = 1000, eps = gmo1@data,   sigmasq = gmo1@h.t, seed = 1234) gmo1.pred$pi_plugin #>          lwr    upr #> [1,] -0.7521 0.7521 #> [2,] -0.7643 0.7643 #> [3,] -0.7758 0.7758 #> [4,] -0.7867 0.7867 #> [5,] -0.7970 0.7970 gmo1.pred$pi_sim #>         2.5%  97.5% #> [1,] -0.7408 0.7466 #> [2,] -0.7688 0.7601 #> [3,] -0.7631 0.7760 #> [4,] -0.7539 0.7210 #> [5,] -0.7779 0.8050  op <- options(op) # restore options(digits)"},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate GARCH(1,1) time series — sim_garch1c1","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"Simulate GARCH(1,1) time series.","code":""},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"","code":"sim_garch1c1(model, n, n.start = 0, seed = NULL)"},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"model GARCH(1,1) model, object obtained GarchModel. n length generated time series. n.start number warm-values, dropped. seed integer use setting random number generator.","code":""},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"list components: eps time series, h (squared) volatilities, eta standardised innovations, model GARCH(1,1) model, .sim list containing parameters simulation, call call.","code":""},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"simulated time series component eps returned value. exploration algorithms eestimation procedures, volatilities standardised innovations also returned. random seed start simulations saved returned object.  speficific seed can requested argument seed. case simulations done specified seed old state random number generator restored function returns.","code":""},{"path":"https://geobosh.github.io/cvar/reference/sim_garch1c1.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Simulate GARCH(1,1) time series — sim_garch1c1","text":"function development may changed.","code":""}]
